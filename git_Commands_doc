Configuring User Information
Before you start using Git, itâ€™s crucial to configure your user information. This ensures your commits are properly attributed.
git config --global user.name "Your Name"

git config --global user.email "your.email@example.com"
Initializing and Cloning Repositories
git init
To start a new project with Git, initialize a new repository:
Scenario: You are beginning a new project and need to set up version control.
mkdir my-new-project

cd my-new-project

git init
This creates a new Git repository in the my-new-project directory.

git clone
Clone an existing repository from a remote source:
Scenario: You need to work on a project that already exists in a remote repository.
git clone https://github.com/UserName/RepoName.git
This command creates a local copy of the repository .
Basic Workflow Commands
Checking Status
Use git status check the current state of your working directory and staging area:
Scenario: You want to see which changes have been staged, which havenâ€™t, and which files arenâ€™t being tracked by Git.
git status
Example output:
On branch main

Your branch is up to date with 'origin/main'.

Untracked files:

  (use "git add <file>..." to include in what will be committed)

    newfile.txt

nothing added to commit but untracked files present (use "git add" to track)

Adding Changes
Stage changes for the next commit using git add :
Scenario: Youâ€™ve made changes to a file and want to stage them for commit.
# Stage a specific file
git add filename


# Stage all changes in the working directory
git add .
Example:
git add newfile.txt

Committing Changes
Commit the staged changes to your local repository:
Scenario: Youâ€™ve staged your changes and now want to commit them with a message describing what youâ€™ve done.
git commit -m "Add new feature"
Example:
git commit -m "Add new file for feature X"

Pushing Changes
Push commits to a remote repository:
Scenario: You want to share your committed changes with others by pushing them to the remote repository.
git push origin branch-name
Example:
git push origin main

Pulling Changes
Fetch and merge changes from the remote repository:
Scenario: You want to update your local repository with the latest changes from the remote repository.
git pull origin branch-name
Example:
git pull origin main
Branching and Merging
Creating and Managing Branches
List, create, or delete branches using git branch:
Scenario: You want to create a new branch to work on a feature without affecting the main branch.
# List all branches
git branch


# Create a new branch
git branch new-branch


# Delete a branch
git branch -d branch-name
Example:
git branch feature-branch
Switch between branches with git checkout :
Scenario: You need to switch to a different branch to work on a different feature or bug fix.
# Switch to an existing branch
git checkout branch-name


# Create and switch to a new branch
git checkout -b new-branch
Example:
git checkout -b feature-branch

Merging Branches
Merge changes from one branch into another.
Scenario: Youâ€™ve completed work on a feature branch and want to integrate those changes into the main branch.
git merge branch-name
Example:
# Switch to the main branch
git checkout main


# Merge the feature branch into the main branch
git merge feature-branch
Advanced Commands
Rebase
Rebasing re-applies commits on top of another base tip, useful for maintaining a clean history:
Scenario: You want to reapply your feature branch changes on top of the latest changes from the main branch, avoiding merge commits.
# Ensure you are on your feature branch
git checkout feature-branch


# Rebase the feature branch onto main
git rebase main
Handling Uncommitted Changes with git stash
Stash saves your changes temporarily, allowing you to switch branches or pull updates without committing unfinished work.
Saving Changes
Scenario: You need to switch branches but donâ€™t want to commit your current changes.
git stash
Example:
# Save current changes
git stash

Applying Stashes
Scenario: You want to reapply the stashed changes after switching back to your branch.
git stash apply
Example:
# Apply the most recent stash
git stash apply

Listing Stashes
Scenario: You want to see a list of all stashes.
git stash list
Example:
# List all stashes
git stash list
Example output:
stash@{0}: WIP on feature-branch: 1234567 Add new feature

stash@{1}: WIP on main: 89abcdef Fix bug

Popping Stashes
Scenario: You want to apply the most recent stash and remove it from the stash list.
git stash pop
Example:
# Apply the most recent stash and remove it from the stash list
git stash pop
Viewing and Managing Commit History
Viewing Logs
Scenario: You want to see the commit history of your project.
git log
Example:
# Show the commit history with details
git log


# Show the commit history with one-line summaries
git log --oneline
Example output:
abcdef1 (HEAD -> main) Fix critical bug

1234567 Add new feature

89abcdef Update documentation

Showing Differences
Scenario: You want to see the differences between your working directory and the last commit, or between two commits.
git diff
Example:
# Show changes in the working directory
git diff


# Show changes between two branches
git diff branch1 branch2


# Show changes between a commit and the working directory
git diff commit_id

Blaming Changes
Scenario: You want to see which commit and author last modified each line of a file.
git blame filename
Example:
git blame myfile.txt
Example output:
abcdef1 (John Doe 2024-05-01 12:34:56) Line 1

1234567 (Jane Smith 2024-05-02 14:56:78) Line 2
Collaborating with Remote Repositories
Managing Remotes
Scenario: You want to list, add, or remove remote repositories.
# List all remotes
git remote -v


# Add a new remote
git remote add origin https://github.com/userName/repoName.git


# Remove a remote
git remote remove origin
Example:
git remote add origin https://github.com/userName/repoName.git

Fetching Updates
Scenario: You want to fetch updates from a remote repository without merging them.
git fetch origin
Example:
# Fetch updates from the remote repository
git fetch origin
Fetch vs Pull
git fetch: This command downloads the latest changes from the remote repository, but it does not automatically merge them into your local branch. It updates your remote tracking branches (origin/main, origin/feature-branch, etc.) to reflect the changes on the remote repository. You can then review the changes and decide if you want to merge them into your local branch using git merge or git rebase.
git pull: This command is a combination of git fetch and git merge. It downloads the latest changes from the remote repository and automatically merges them into your current local branch. This can be convenient for quickly updating your local branch with the latest changes from the remote repository, but it may also result in conflicts that need to be resolved manually.
In summary, git fetch fetches the latest changes from the remote repository without merging them, while git pull fetches and merges the changes automatically.
Tags and Releases
Creating and Managing Tags
Scenario: You want to create a new tag for a release and push it to the remote repository.
# List all tags
git tag


# Create a new tag
git tag -a v1.0 -m "Version 1.0"


# Push tags to the remote repository
git push origin --tags
Example:
git tag -a v1.0 -m "First release version 1.0"

git push origin --tags
Debugging and Fixing Issues
Using `git bisect` for Bug Hunting
Scenario: You want to find the commit that introduced a bug using binary search.
# Start the bisect process
git bisect start


# Mark the current commit as bad
git bisect bad


# Mark an earlier commit as good
git bisect good abc1234
Example:
git bisect start

git bisect bad

git bisect good 89abcdef
Working with Submodules
Managing Submodules
Scenario: You want to add, initialize, or update submodules in your project.
# Add a new submodule
git submodule add https://github.com/userName/repoName.git path/to/submodule


# Initialize and update submodules
git submodule update --init --recursive
Example:
git submodule add https://github.com/userName/library.git lib/library

git submodule update --init --recursive
Cleaning Up
Removing Untracked Files
Scenario: You want to clean up your working directory by removing untracked files and directories.
# Show what would be removed
git clean -n


# Remove untracked files
git clean -f


# Remove untracked directories
git clean -fd
Example:
git clean -n   # Dry run to see what will be removed

git clean -f   # Remove untracked files

git clean -fd  # Remove untracked files and directories
Using Reflog for Recovery
Viewing Reference Logs
Scenario: You want to view the reference log to see where your HEAD has been.
git reflog
Example:
# View the reference log
git reflog
Example output:
abcdef1 HEAD@{0}: commit: Fix critical bug

1234567 HEAD@{1}: commit: Add new feature

89abcdef HEAD@{2}: commit: Update documentation
Combining Commands for Efficient Workflows
1. Reverting to a Previous Commit
Scenario: You want to reset your branch to a specific previous commit.
# Find the commit hash
git log --oneline  


# Reset the branch to a specific commit
git reset --hard abc1234 
2. Undoing a Commit Without Losing Changes
Scenario: You want to undo your last commit but keep the changes in the working directory.
# Reset the last commit, keeping changes in the working directory   
git reset --soft HEAD~1 
3. Creating a Pull Request Branch
Scenario: You want to create a new branch for a pull request and push it to the remote repository.
# Create a new branch from main   
git checkout -b feature-branch  


 # Push the branch to the remote repository
git push origin feature-branch 
4. Updating a Branch with Changes from Main
Scenario: You want to update your feature branch with the latest changes from the main branch.
# Switch to the main branch   
git checkout main  


# Pull the latest changes
git pull origin main 


# Switch back to the feature branch
git checkout feature-branch  




Follow
ðŸš€ Mastering Git: Essential Commands for Professional Developers ðŸš€

Hey LinkedIn Network!

Are you looking to enhance your Git skills and streamline your development workflow? I've just published an in-depth article covering the most essential Git commands with detailed explanations, practical scenarios, and real-world examples.

Whether you're a seasoned developer or just starting out, understanding these commands can significantly boost your productivity and ensure seamless collaboration within your team.

ðŸ“Œ Highlights of the Article:

1. Setting Up Git: Learn how to configure user information and initialize repositories.
2. Basic Workflow Commands: Master git add, git commit, git push, and more.
3. Branching and Merging: Efficiently manage and merge branches.
Advanced Commands: Understand git rebase, git stash, and more complex operations.
4. Collaborating with Remote Repositories: Fetch, pull, and push changes like a pro.
5. Debugging and Fixing Issues: Use git bisect and other tools to hunt down bugs.


ðŸ’¡ Why You Should Read It:

1. Real-World Scenarios: Each command is paired with practical examples and scenarios youâ€™ll encounter in your projects.
2. Professional Insight: Gain insights that help maintain a clean project history and improve team collaboration.
3. Comprehensive Guide: This article is a one-stop resource for all your Git needs.